2024.05.12 14:01:23 INFO  Started: Metals version 1.3.0 in folders 'D:\HTWG\Master\Concurrency\ConcurrencyScala' for client Visual Studio Code 1.89.0.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@1192636c]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@67e6a899]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@1192636c]
2024.05.12 14:01:24 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
Mai 12, 2024 2:01:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3
Mai 12, 2024 2:01:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 6
Mai 12, 2024 2:01:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 2
Mai 12, 2024 2:01:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1
2024.05.12 14:01:48 INFO  no build target found for D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.05.12 14:12:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:13:33 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:14:29 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:15:17 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:16:02 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:16:47 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:19:59 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:20:47 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:21:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
Mai 12, 2024 2:25:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 462
2024.05.12 14:31:48 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:34:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:40:25 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:40:25 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:40:26 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 2:40:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\npackage java.nio.charset;\n\n/**\n * Constant definitions for the standard {@link Charset charsets}. These\n * charsets are guaranteed to be available on every implementation of the Java\n * platform.\n *\n * @see \u003ca href\u003d\"Charset.html#standard\"\u003eStandard Charsets\u003c/a\u003e\n * @since 1.7\n */\npublic final class StandardCharsets {\n\n    // To avoid accidental eager initialization of often unused Charsets\n    // from happening while the VM is booting up, which may delay\n    // initialization of VM components, we should generally avoid depending\n    // on this class from elsewhere in java.base.\n\n    private StandardCharsets() {\n        throw new AssertionError(\"No java.nio.charset.StandardCharsets instances for you!\");\n    }\n\n    /**\n     * Seven-bit ASCII, also known as ISO646-US, also known as the\n     * Basic Latin block of the Unicode character set.\n     */\n    public static final Charset US_ASCII \u003d sun.nio.cs.US_ASCII.INSTANCE;\n\n    /**\n     * ISO Latin Alphabet {@literal No. 1}, also known as ISO-LATIN-1.\n     */\n    public static final Charset ISO_8859_1 \u003d sun.nio.cs.ISO_8859_1.INSTANCE;\n\n    /**\n     * Eight-bit UCS Transformation Format.\n     */\n    public static final Charset UTF_8 \u003d sun.nio.cs.UTF_8.INSTANCE;\n\n    /**\n     * Sixteen-bit UCS Transformation Format, big-endian byte order.\n     */\n    public static final Charset UTF_16BE \u003d new sun.nio.cs.UTF_16BE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, little-endian byte order.\n     */\n    public static final Charset UTF_16LE \u003d new sun.nio.cs.UTF_16LE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark.\n     */\n    public static final Charset UTF_16 \u003d new sun.nio.cs.UTF_16();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 2:40:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 2:40:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 670
2024.05.12 14:41:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 14:50:53 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:51:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:54:12 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:55:33 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:55:54 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:58:08 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:58:18 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:58:18 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 2:58:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\npackage java.nio.charset;\n\n/**\n * Constant definitions for the standard {@link Charset charsets}. These\n * charsets are guaranteed to be available on every implementation of the Java\n * platform.\n *\n * @see \u003ca href\u003d\"Charset.html#standard\"\u003eStandard Charsets\u003c/a\u003e\n * @since 1.7\n */\npublic final class StandardCharsets {\n\n    // To avoid accidental eager initialization of often unused Charsets\n    // from happening while the VM is booting up, which may delay\n    // initialization of VM components, we should generally avoid depending\n    // on this class from elsewhere in java.base.\n\n    private StandardCharsets() {\n        throw new AssertionError(\"No java.nio.charset.StandardCharsets instances for you!\");\n    }\n\n    /**\n     * Seven-bit ASCII, also known as ISO646-US, also known as the\n     * Basic Latin block of the Unicode character set.\n     */\n    public static final Charset US_ASCII \u003d sun.nio.cs.US_ASCII.INSTANCE;\n\n    /**\n     * ISO Latin Alphabet {@literal No. 1}, also known as ISO-LATIN-1.\n     */\n    public static final Charset ISO_8859_1 \u003d sun.nio.cs.ISO_8859_1.INSTANCE;\n\n    /**\n     * Eight-bit UCS Transformation Format.\n     */\n    public static final Charset UTF_8 \u003d sun.nio.cs.UTF_8.INSTANCE;\n\n    /**\n     * Sixteen-bit UCS Transformation Format, big-endian byte order.\n     */\n    public static final Charset UTF_16BE \u003d new sun.nio.cs.UTF_16BE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, little-endian byte order.\n     */\n    public static final Charset UTF_16LE \u003d new sun.nio.cs.UTF_16LE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark.\n     */\n    public static final Charset UTF_16 \u003d new sun.nio.cs.UTF_16();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 2:58:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.05.12 14:59:06 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:59:27 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 14:59:44 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:01:57 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:06:27 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:08:10 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:10:28 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:12:27 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 3:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/security/MessageDigest.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.security;\n\nimport java.util.*;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.nio.ByteBuffer;\n\nimport sun.security.jca.GetInstance;\nimport sun.security.util.Debug;\nimport sun.security.util.MessageDigestSpi2;\n\nimport javax.crypto.SecretKey;\n\n/**\n * This MessageDigest class provides applications the functionality of a\n * message digest algorithm, such as SHA-1 or SHA-256.\n * Message digests are secure one-way hash functions that take arbitrary-sized\n * data and output a fixed-length hash value.\n *\n * \u003cp\u003eA MessageDigest object starts out initialized. The data is\n * processed through it using the {@link #update(byte) update}\n * methods. At any point {@link #reset() reset} can be called\n * to reset the digest. Once all the data to be updated has been\n * updated, one of the {@link #digest() digest} methods should\n * be called to complete the hash computation.\n *\n * \u003cp\u003eThe {@code digest} method can be called once for a given number\n * of updates. After {@code digest} has been called, the MessageDigest\n * object is reset to its initialized state.\n *\n * \u003cp\u003eImplementations are free to implement the Cloneable interface.\n * Client applications can test cloneability by attempting cloning\n * and catching the CloneNotSupportedException:\n *\n * \u003cpre\u003e{@code\n * MessageDigest md \u003d MessageDigest.getInstance(\"SHA-256\");\n *\n * try {\n *     md.update(toChapter1);\n *     MessageDigest tc1 \u003d md.clone();\n *     byte[] toChapter1Digest \u003d tc1.digest();\n *     md.update(toChapter2);\n *     ...etc.\n * } catch (CloneNotSupportedException cnse) {\n *     throw new DigestException(\"couldn\u0027t make digest of partial content\");\n * }\n * }\u003c/pre\u003e\n *\n * \u003cp\u003eNote that if a given implementation is not cloneable, it is\n * still possible to compute intermediate digests by instantiating\n * several instances, if the number of digests is known in advance.\n *\n * \u003cp\u003eNote that this class is abstract and extends from\n * {@code MessageDigestSpi} for historical reasons.\n * Application developers should only take notice of the methods defined in\n * this {@code MessageDigest} class; all the methods in\n * the superclass are intended for cryptographic service providers who wish to\n * supply their own implementations of message digest algorithms.\n *\n * \u003cp\u003e Every implementation of the Java platform is required to support\n * the following standard {@code MessageDigest} algorithms:\n * \u003cul\u003e\n * \u003cli\u003e{@code SHA-1}\u003c/li\u003e\n * \u003cli\u003e{@code SHA-256}\u003c/li\u003e\n * \u003c/ul\u003e\n * These algorithms are described in the \u003ca href\u003d\n * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n * MessageDigest section\u003c/a\u003e of the\n * Java Security Standard Algorithm Names Specification.\n * Consult the release documentation for your implementation to see if any\n * other algorithms are supported.\n *\n * @author Benjamin Renaud\n * @since 1.1\n *\n * @see DigestInputStream\n * @see DigestOutputStream\n */\n\npublic abstract class MessageDigest extends MessageDigestSpi {\n\n    private static final Debug pdebug \u003d\n                        Debug.getInstance(\"provider\", \"Provider\");\n    private static final boolean skipDebug \u003d\n        Debug.isOn(\"engine\u003d\") \u0026\u0026 !Debug.isOn(\"messagedigest\");\n\n    private String algorithm;\n\n    // The state of this digest\n    private static final int INITIAL \u003d 0;\n    private static final int IN_PROGRESS \u003d 1;\n    private int state \u003d INITIAL;\n\n    // The provider\n    private Provider provider;\n\n    /**\n     * Creates a message digest with the specified algorithm name.\n     *\n     * @param algorithm the standard name of the digest algorithm.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     */\n    protected MessageDigest(String algorithm) {\n        this.algorithm \u003d algorithm;\n    }\n\n    // private constructor used only by Delegate class\n    private MessageDigest(String algorithm, Provider p) {\n        this.algorithm \u003d algorithm;\n        this.provider \u003d p;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e This method traverses the list of registered security Providers,\n     * starting with the most preferred Provider.\n     * A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the first\n     * Provider that supports the specified algorithm is returned.\n     *\n     * \u003cp\u003e Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @implNote\n     * The JDK Reference Implementation additionally uses the\n     * {@code jdk.security.provider.preferred}\n     * {@link Security#getProperty(String) Security} property to determine\n     * the preferred provider order for the specified algorithm. This\n     * may be different than the order of providers returned by\n     * {@link Security#getProviders() Security.getProviders()}.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws NoSuchAlgorithmException if no {@code Provider} supports a\n     *         {@code MessageDigestSpi} implementation for the\n     *         specified algorithm\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     */\n    public static MessageDigest getInstance(String algorithm)\n        throws NoSuchAlgorithmException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        MessageDigest md;\n\n        GetInstance.Instance instance \u003d GetInstance.getInstance(\"MessageDigest\",\n                MessageDigestSpi.class, algorithm);\n        if (instance.impl instanceof MessageDigest messageDigest) {\n            md \u003d messageDigest;\n            md.provider \u003d instance.provider;\n        } else {\n            md \u003d Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n                instance.provider);\n        }\n\n        if (!skipDebug \u0026\u0026 pdebug !\u003d null) {\n            pdebug.println(\"MessageDigest.\" + algorithm +\n                \" algorithm from: \" + md.provider.getName());\n        }\n\n        return md;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the specified provider\n     * is returned.  The specified provider must be registered\n     * in the security provider list.\n     *\n     * \u003cp\u003e Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @param provider the name of the provider.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws IllegalArgumentException if the provider name is {@code null}\n     *         or empty\n     *\n     * @throws NoSuchAlgorithmException if a {@code MessageDigestSpi}\n     *         implementation for the specified algorithm is not\n     *         available from the specified provider\n     *\n     * @throws NoSuchProviderException if the specified provider is not\n     *         registered in the security provider list\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     */\n    public static MessageDigest getInstance(String algorithm, String provider)\n        throws NoSuchAlgorithmException, NoSuchProviderException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        if (provider \u003d\u003d null || provider.isEmpty())\n            throw new IllegalArgumentException(\"missing provider\");\n\n        MessageDigest md;\n        GetInstance.Instance instance \u003d GetInstance.getInstance(\"MessageDigest\",\n                MessageDigestSpi.class, algorithm, provider);\n        if (instance.impl instanceof MessageDigest messageDigest) {\n            md \u003d messageDigest;\n            md.provider \u003d instance.provider;\n        } else {\n            md \u003d Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n                    instance.provider);\n        }\n        return md;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the specified Provider\n     * object is returned.  Note that the specified Provider object\n     * does not have to be registered in the provider list.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @param provider the provider.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws IllegalArgumentException if the specified provider is\n     *         {@code null}\n     *\n     * @throws NoSuchAlgorithmException if a {@code MessageDigestSpi}\n     *         implementation for the specified algorithm is not available\n     *         from the specified {@code Provider} object\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     *\n     * @since 1.4\n     */\n    public static MessageDigest getInstance(String algorithm,\n                                            Provider provider)\n        throws NoSuchAlgorithmException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        if (provider \u003d\u003d null)\n            throw new IllegalArgumentException(\"missing provider\");\n        Object[] objs \u003d Security.getImpl(algorithm, \"MessageDigest\", provider);\n        if (objs[0] instanceof MessageDigest md) {\n            md.provider \u003d (Provider)objs[1];\n            return md;\n        } else {\n            MessageDigest delegate \u003d\n                    Delegate.of((MessageDigestSpi)objs[0], algorithm,\n                    (Provider)objs[1]);\n            return delegate;\n        }\n    }\n\n    /**\n     * Returns the provider of this message digest object.\n     *\n     * @return the provider of this message digest object\n     */\n    public final Provider getProvider() {\n        return this.provider;\n    }\n\n    /**\n     * Updates the digest using the specified byte.\n     *\n     * @param input the byte with which to update the digest.\n     */\n    public void update(byte input) {\n        engineUpdate(input);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Updates the digest using the specified array of bytes, starting\n     * at the specified offset.\n     *\n     * @param input the array of bytes.\n     *\n     * @param offset the offset to start from in the array of bytes.\n     *\n     * @param len the number of bytes to use, starting at\n     * {@code offset}.\n     */\n    public void update(byte[] input, int offset, int len) {\n        if (input \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No input buffer given\");\n        }\n        if (input.length - offset \u003c len) {\n            throw new IllegalArgumentException(\"Input buffer too short\");\n        }\n        engineUpdate(input, offset, len);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Updates the digest using the specified array of bytes.\n     *\n     * @param input the array of bytes.\n     */\n    public void update(byte[] input) {\n        engineUpdate(input, 0, input.length);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Update the digest using the specified ByteBuffer. The digest is\n     * updated using the {@code input.remaining()} bytes starting\n     * at {@code input.position()}.\n     * Upon return, the buffer\u0027s position will be equal to its limit;\n     * its limit will not have changed.\n     *\n     * @param input the ByteBuffer\n     * @since 1.5\n     */\n    public final void update(ByteBuffer input) {\n        if (input \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        engineUpdate(input);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Completes the hash computation by performing final operations\n     * such as padding. The digest is reset after this call is made.\n     *\n     * @return the array of bytes for the resulting hash value.\n     */\n    public byte[] digest() {\n        /* Resetting is the responsibility of implementors. */\n        byte[] result \u003d engineDigest();\n        state \u003d INITIAL;\n        return result;\n    }\n\n    /**\n     * Completes the hash computation by performing final operations\n     * such as padding. The digest is reset after this call is made.\n     *\n     * @param buf output buffer for the computed digest\n     *\n     * @param offset offset into the output buffer to begin storing the digest\n     *\n     * @param len number of bytes within buf allotted for the digest\n     *\n     * @return the number of bytes placed into {@code buf}\n     *\n     * @throws    DigestException if an error occurs.\n     */\n    public int digest(byte[] buf, int offset, int len) throws DigestException {\n        if (buf \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No output buffer given\");\n        }\n        if (buf.length - offset \u003c len) {\n            throw new IllegalArgumentException\n                (\"Output buffer too small for specified offset and length\");\n        }\n        int numBytes \u003d engineDigest(buf, offset, len);\n        state \u003d INITIAL;\n        return numBytes;\n    }\n\n    /**\n     * Performs a final update on the digest using the specified array\n     * of bytes, then completes the digest computation. That is, this\n     * method first calls {@link #update(byte[]) update(input)},\n     * passing the \u003ci\u003einput\u003c/i\u003e array to the {@code update} method,\n     * then calls {@link #digest() digest()}.\n     *\n     * @param input the input to be updated before the digest is\n     * completed.\n     *\n     * @return the array of bytes for the resulting hash value.\n     */\n    public byte[] digest(byte[] input) {\n        update(input);\n        return digest();\n    }\n\n    private String getProviderName() {\n        return (provider \u003d\u003d null) ? \"(no provider)\" : provider.getName();\n    }\n\n    /**\n     * Returns a string representation of this message digest object.\n     */\n    public String toString() {\n        ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n        PrintStream p \u003d new PrintStream(baos);\n        p.print(algorithm+\" Message Digest from \"+getProviderName()+\", \");\n        switch (state) {\n        case INITIAL:\n            p.print(\"\u003cinitialized\u003e\");\n            break;\n        case IN_PROGRESS:\n            p.print(\"\u003cin progress\u003e\");\n            break;\n        }\n        p.println();\n        return (baos.toString());\n    }\n\n    /**\n     * Compares two digests for equality. Two digests are equal if they have\n     * the same length and all bytes at corresponding positions are equal.\n     *\n     * @implNote\n     * All bytes in {@code digesta} are examined to determine equality.\n     * The calculation time depends only on the length of {@code digesta}.\n     * It does not depend on the length of {@code digestb} or the contents\n     * of {@code digesta} and {@code digestb}.\n     *\n     * @param digesta one of the digests to compare.\n     *\n     * @param digestb the other digest to compare.\n     *\n     * @return true if the digests are equal, false otherwise.\n     */\n    public static boolean isEqual(byte[] digesta, byte[] digestb) {\n        if (digesta \u003d\u003d digestb) return true;\n        if (digesta \u003d\u003d null || digestb \u003d\u003d null) {\n            return false;\n        }\n\n        int lenA \u003d digesta.length;\n        int lenB \u003d digestb.length;\n\n        if (lenB \u003d\u003d 0) {\n            return lenA \u003d\u003d 0;\n        }\n\n        int result \u003d 0;\n        result |\u003d lenA - lenB;\n\n        // time-constant comparison\n        for (int i \u003d 0; i \u003c lenA; i++) {\n            // If i \u003e\u003d lenB, indexB is 0; otherwise, i.\n            int indexB \u003d ((i - lenB) \u003e\u003e\u003e 31) * i;\n            result |\u003d digesta[i] ^ digestb[indexB];\n        }\n        return result \u003d\u003d 0;\n    }\n\n    /**\n     * Resets the digest for further use.\n     */\n    public void reset() {\n        engineReset();\n        state \u003d INITIAL;\n    }\n\n    /**\n     * Returns a string that identifies the algorithm, independent of\n     * implementation details. The name should be a standard\n     * Java Security name (such as \"SHA-256\").\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @return the name of the algorithm\n     */\n    public final String getAlgorithm() {\n        return this.algorithm;\n    }\n\n    /**\n     * Returns the length of the digest in bytes, or 0 if this operation is\n     * not supported by the provider and the implementation is not cloneable.\n     *\n     * @return the digest length in bytes, or 0 if this operation is not\n     * supported by the provider and the implementation is not cloneable.\n     *\n     * @since 1.2\n     */\n    public final int getDigestLength() {\n        int digestLen \u003d engineGetDigestLength();\n        if (digestLen \u003d\u003d 0) {\n            try {\n                MessageDigest md \u003d (MessageDigest)clone();\n                byte[] digest \u003d md.digest();\n                return digest.length;\n            } catch (CloneNotSupportedException e) {\n                return digestLen;\n            }\n        }\n        return digestLen;\n    }\n\n    /**\n     * Returns a clone if the implementation is cloneable.\n     *\n     * @return a clone if the implementation is cloneable.\n     *\n     * @throws    CloneNotSupportedException if this is called on an\n     * implementation that does not support {@code Cloneable}.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        if (this instanceof Cloneable) {\n            return super.clone();\n        } else {\n            throw new CloneNotSupportedException();\n        }\n    }\n\n\n    /*\n     * The following class allows providers to extend from MessageDigestSpi\n     * rather than from MessageDigest. It represents a MessageDigest with an\n     * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).\n     * If the provider implementation is an instance of MessageDigestSpi,\n     * the getInstance() methods above return an instance of this class, with\n     * the SPI object encapsulated.\n     *\n     * Note: All SPI methods from the original MessageDigest class have been\n     * moved up the hierarchy into a new class (MessageDigestSpi), which has\n     * been interposed in the hierarchy between the API (MessageDigest)\n     * and its original parent (Object).\n     */\n\n    private static class Delegate extends MessageDigest\n            implements MessageDigestSpi2 {\n        // use this class for spi objects which implements Cloneable\n        private static final class CloneableDelegate extends Delegate\n                implements Cloneable {\n\n            private CloneableDelegate(MessageDigestSpi digestSpi,\n                    String algorithm, Provider p) {\n                super(digestSpi, algorithm, p);\n            }\n        }\n\n        // The provider implementation (delegate)\n        private final MessageDigestSpi digestSpi;\n\n        // factory method used by MessageDigest class to create Delegate objs\n        static Delegate of(MessageDigestSpi digestSpi, String algo,\n                Provider p) {\n            Objects.requireNonNull(digestSpi);\n            boolean isCloneable \u003d (digestSpi instanceof Cloneable);\n            // Spi impls from SunPKCS11 provider implement Cloneable but their\n            // clone() may throw CloneNotSupportException\n            if (isCloneable \u0026\u0026 p.getName().startsWith(\"SunPKCS11\") \u0026\u0026\n                    p.getClass().getModule().getName().equals\n                    (\"jdk.crypto.cryptoki\")) {\n                try {\n                    digestSpi.clone();\n                } catch (CloneNotSupportedException cnse) {\n                    isCloneable \u003d false;\n                }\n            }\n            return (isCloneable? new CloneableDelegate(digestSpi, algo, p) :\n                    new Delegate(digestSpi, algo, p));\n        }\n\n        // private constructor\n        private Delegate(MessageDigestSpi digestSpi, String algorithm,\n                Provider p) {\n            super(algorithm, p);\n            this.digestSpi \u003d digestSpi;\n        }\n\n        /**\n         * Returns a clone if the delegate is cloneable.\n         *\n         * @return a clone if the delegate is cloneable.\n         *\n         * @throws    CloneNotSupportedException if this is called on a\n         * delegate that does not support {@code Cloneable}.\n         */\n        @Override\n        public Object clone() throws CloneNotSupportedException {\n            if (this instanceof Cloneable) {\n                // Because \u0027algorithm\u0027, \u0027provider\u0027, and \u0027state\u0027 are private\n                // members of our supertype, we must perform a cast to\n                // access them.\n                MessageDigest that \u003d new CloneableDelegate(\n                        (MessageDigestSpi)digestSpi.clone(),\n                        ((MessageDigest)this).algorithm,\n                        ((MessageDigest)this).provider);\n                that.state \u003d ((MessageDigest)this).state;\n                return that;\n            } else {\n                throw new CloneNotSupportedException();\n            }\n        }\n\n        @Override\n        protected int engineGetDigestLength() {\n            return digestSpi.engineGetDigestLength();\n        }\n\n        @Override\n        protected void engineUpdate(byte input) {\n            digestSpi.engineUpdate(input);\n        }\n\n        @Override\n        protected void engineUpdate(byte[] input, int offset, int len) {\n            digestSpi.engineUpdate(input, offset, len);\n        }\n\n        @Override\n        protected void engineUpdate(ByteBuffer input) {\n            digestSpi.engineUpdate(input);\n        }\n\n        @Override\n        public void engineUpdate(SecretKey key) throws InvalidKeyException {\n            if (digestSpi instanceof MessageDigestSpi2) {\n                ((MessageDigestSpi2)digestSpi).engineUpdate(key);\n            } else {\n                throw new UnsupportedOperationException\n                (\"Digest does not support update of SecretKey object\");\n            }\n        }\n\n        @Override\n        protected byte[] engineDigest() {\n            return digestSpi.engineDigest();\n        }\n\n        @Override\n        protected int engineDigest(byte[] buf, int offset, int len)\n            throws DigestException {\n                return digestSpi.engineDigest(buf, offset, len);\n        }\n\n        @Override\n        protected void engineReset() {\n            digestSpi.engineReset();\n        }\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 3:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/security/MessageDigest.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.05.12 15:12:27 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 3:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/security/MessageDigest.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.security;\n\nimport java.util.*;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.nio.ByteBuffer;\n\nimport sun.security.jca.GetInstance;\nimport sun.security.util.Debug;\nimport sun.security.util.MessageDigestSpi2;\n\nimport javax.crypto.SecretKey;\n\n/**\n * This MessageDigest class provides applications the functionality of a\n * message digest algorithm, such as SHA-1 or SHA-256.\n * Message digests are secure one-way hash functions that take arbitrary-sized\n * data and output a fixed-length hash value.\n *\n * \u003cp\u003eA MessageDigest object starts out initialized. The data is\n * processed through it using the {@link #update(byte) update}\n * methods. At any point {@link #reset() reset} can be called\n * to reset the digest. Once all the data to be updated has been\n * updated, one of the {@link #digest() digest} methods should\n * be called to complete the hash computation.\n *\n * \u003cp\u003eThe {@code digest} method can be called once for a given number\n * of updates. After {@code digest} has been called, the MessageDigest\n * object is reset to its initialized state.\n *\n * \u003cp\u003eImplementations are free to implement the Cloneable interface.\n * Client applications can test cloneability by attempting cloning\n * and catching the CloneNotSupportedException:\n *\n * \u003cpre\u003e{@code\n * MessageDigest md \u003d MessageDigest.getInstance(\"SHA-256\");\n *\n * try {\n *     md.update(toChapter1);\n *     MessageDigest tc1 \u003d md.clone();\n *     byte[] toChapter1Digest \u003d tc1.digest();\n *     md.update(toChapter2);\n *     ...etc.\n * } catch (CloneNotSupportedException cnse) {\n *     throw new DigestException(\"couldn\u0027t make digest of partial content\");\n * }\n * }\u003c/pre\u003e\n *\n * \u003cp\u003eNote that if a given implementation is not cloneable, it is\n * still possible to compute intermediate digests by instantiating\n * several instances, if the number of digests is known in advance.\n *\n * \u003cp\u003eNote that this class is abstract and extends from\n * {@code MessageDigestSpi} for historical reasons.\n * Application developers should only take notice of the methods defined in\n * this {@code MessageDigest} class; all the methods in\n * the superclass are intended for cryptographic service providers who wish to\n * supply their own implementations of message digest algorithms.\n *\n * \u003cp\u003e Every implementation of the Java platform is required to support\n * the following standard {@code MessageDigest} algorithms:\n * \u003cul\u003e\n * \u003cli\u003e{@code SHA-1}\u003c/li\u003e\n * \u003cli\u003e{@code SHA-256}\u003c/li\u003e\n * \u003c/ul\u003e\n * These algorithms are described in the \u003ca href\u003d\n * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n * MessageDigest section\u003c/a\u003e of the\n * Java Security Standard Algorithm Names Specification.\n * Consult the release documentation for your implementation to see if any\n * other algorithms are supported.\n *\n * @author Benjamin Renaud\n * @since 1.1\n *\n * @see DigestInputStream\n * @see DigestOutputStream\n */\n\npublic abstract class MessageDigest extends MessageDigestSpi {\n\n    private static final Debug pdebug \u003d\n                        Debug.getInstance(\"provider\", \"Provider\");\n    private static final boolean skipDebug \u003d\n        Debug.isOn(\"engine\u003d\") \u0026\u0026 !Debug.isOn(\"messagedigest\");\n\n    private String algorithm;\n\n    // The state of this digest\n    private static final int INITIAL \u003d 0;\n    private static final int IN_PROGRESS \u003d 1;\n    private int state \u003d INITIAL;\n\n    // The provider\n    private Provider provider;\n\n    /**\n     * Creates a message digest with the specified algorithm name.\n     *\n     * @param algorithm the standard name of the digest algorithm.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     */\n    protected MessageDigest(String algorithm) {\n        this.algorithm \u003d algorithm;\n    }\n\n    // private constructor used only by Delegate class\n    private MessageDigest(String algorithm, Provider p) {\n        this.algorithm \u003d algorithm;\n        this.provider \u003d p;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e This method traverses the list of registered security Providers,\n     * starting with the most preferred Provider.\n     * A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the first\n     * Provider that supports the specified algorithm is returned.\n     *\n     * \u003cp\u003e Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @implNote\n     * The JDK Reference Implementation additionally uses the\n     * {@code jdk.security.provider.preferred}\n     * {@link Security#getProperty(String) Security} property to determine\n     * the preferred provider order for the specified algorithm. This\n     * may be different than the order of providers returned by\n     * {@link Security#getProviders() Security.getProviders()}.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws NoSuchAlgorithmException if no {@code Provider} supports a\n     *         {@code MessageDigestSpi} implementation for the\n     *         specified algorithm\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     */\n    public static MessageDigest getInstance(String algorithm)\n        throws NoSuchAlgorithmException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        MessageDigest md;\n\n        GetInstance.Instance instance \u003d GetInstance.getInstance(\"MessageDigest\",\n                MessageDigestSpi.class, algorithm);\n        if (instance.impl instanceof MessageDigest messageDigest) {\n            md \u003d messageDigest;\n            md.provider \u003d instance.provider;\n        } else {\n            md \u003d Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n                instance.provider);\n        }\n\n        if (!skipDebug \u0026\u0026 pdebug !\u003d null) {\n            pdebug.println(\"MessageDigest.\" + algorithm +\n                \" algorithm from: \" + md.provider.getName());\n        }\n\n        return md;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the specified provider\n     * is returned.  The specified provider must be registered\n     * in the security provider list.\n     *\n     * \u003cp\u003e Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @param provider the name of the provider.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws IllegalArgumentException if the provider name is {@code null}\n     *         or empty\n     *\n     * @throws NoSuchAlgorithmException if a {@code MessageDigestSpi}\n     *         implementation for the specified algorithm is not\n     *         available from the specified provider\n     *\n     * @throws NoSuchProviderException if the specified provider is not\n     *         registered in the security provider list\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     */\n    public static MessageDigest getInstance(String algorithm, String provider)\n        throws NoSuchAlgorithmException, NoSuchProviderException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        if (provider \u003d\u003d null || provider.isEmpty())\n            throw new IllegalArgumentException(\"missing provider\");\n\n        MessageDigest md;\n        GetInstance.Instance instance \u003d GetInstance.getInstance(\"MessageDigest\",\n                MessageDigestSpi.class, algorithm, provider);\n        if (instance.impl instanceof MessageDigest messageDigest) {\n            md \u003d messageDigest;\n            md.provider \u003d instance.provider;\n        } else {\n            md \u003d Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n                    instance.provider);\n        }\n        return md;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the specified Provider\n     * object is returned.  Note that the specified Provider object\n     * does not have to be registered in the provider list.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @param provider the provider.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws IllegalArgumentException if the specified provider is\n     *         {@code null}\n     *\n     * @throws NoSuchAlgorithmException if a {@code MessageDigestSpi}\n     *         implementation for the specified algorithm is not available\n     *         from the specified {@code Provider} object\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     *\n     * @since 1.4\n     */\n    public static MessageDigest getInstance(String algorithm,\n                                            Provider provider)\n        throws NoSuchAlgorithmException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        if (provider \u003d\u003d null)\n            throw new IllegalArgumentException(\"missing provider\");\n        Object[] objs \u003d Security.getImpl(algorithm, \"MessageDigest\", provider);\n        if (objs[0] instanceof MessageDigest md) {\n            md.provider \u003d (Provider)objs[1];\n            return md;\n        } else {\n            MessageDigest delegate \u003d\n                    Delegate.of((MessageDigestSpi)objs[0], algorithm,\n                    (Provider)objs[1]);\n            return delegate;\n        }\n    }\n\n    /**\n     * Returns the provider of this message digest object.\n     *\n     * @return the provider of this message digest object\n     */\n    public final Provider getProvider() {\n        return this.provider;\n    }\n\n    /**\n     * Updates the digest using the specified byte.\n     *\n     * @param input the byte with which to update the digest.\n     */\n    public void update(byte input) {\n        engineUpdate(input);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Updates the digest using the specified array of bytes, starting\n     * at the specified offset.\n     *\n     * @param input the array of bytes.\n     *\n     * @param offset the offset to start from in the array of bytes.\n     *\n     * @param len the number of bytes to use, starting at\n     * {@code offset}.\n     */\n    public void update(byte[] input, int offset, int len) {\n        if (input \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No input buffer given\");\n        }\n        if (input.length - offset \u003c len) {\n            throw new IllegalArgumentException(\"Input buffer too short\");\n        }\n        engineUpdate(input, offset, len);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Updates the digest using the specified array of bytes.\n     *\n     * @param input the array of bytes.\n     */\n    public void update(byte[] input) {\n        engineUpdate(input, 0, input.length);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Update the digest using the specified ByteBuffer. The digest is\n     * updated using the {@code input.remaining()} bytes starting\n     * at {@code input.position()}.\n     * Upon return, the buffer\u0027s position will be equal to its limit;\n     * its limit will not have changed.\n     *\n     * @param input the ByteBuffer\n     * @since 1.5\n     */\n    public final void update(ByteBuffer input) {\n        if (input \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        engineUpdate(input);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Completes the hash computation by performing final operations\n     * such as padding. The digest is reset after this call is made.\n     *\n     * @return the array of bytes for the resulting hash value.\n     */\n    public byte[] digest() {\n        /* Resetting is the responsibility of implementors. */\n        byte[] result \u003d engineDigest();\n        state \u003d INITIAL;\n        return result;\n    }\n\n    /**\n     * Completes the hash computation by performing final operations\n     * such as padding. The digest is reset after this call is made.\n     *\n     * @param buf output buffer for the computed digest\n     *\n     * @param offset offset into the output buffer to begin storing the digest\n     *\n     * @param len number of bytes within buf allotted for the digest\n     *\n     * @return the number of bytes placed into {@code buf}\n     *\n     * @throws    DigestException if an error occurs.\n     */\n    public int digest(byte[] buf, int offset, int len) throws DigestException {\n        if (buf \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No output buffer given\");\n        }\n        if (buf.length - offset \u003c len) {\n            throw new IllegalArgumentException\n                (\"Output buffer too small for specified offset and length\");\n        }\n        int numBytes \u003d engineDigest(buf, offset, len);\n        state \u003d INITIAL;\n        return numBytes;\n    }\n\n    /**\n     * Performs a final update on the digest using the specified array\n     * of bytes, then completes the digest computation. That is, this\n     * method first calls {@link #update(byte[]) update(input)},\n     * passing the \u003ci\u003einput\u003c/i\u003e array to the {@code update} method,\n     * then calls {@link #digest() digest()}.\n     *\n     * @param input the input to be updated before the digest is\n     * completed.\n     *\n     * @return the array of bytes for the resulting hash value.\n     */\n    public byte[] digest(byte[] input) {\n        update(input);\n        return digest();\n    }\n\n    private String getProviderName() {\n        return (provider \u003d\u003d null) ? \"(no provider)\" : provider.getName();\n    }\n\n    /**\n     * Returns a string representation of this message digest object.\n     */\n    public String toString() {\n        ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n        PrintStream p \u003d new PrintStream(baos);\n        p.print(algorithm+\" Message Digest from \"+getProviderName()+\", \");\n        switch (state) {\n        case INITIAL:\n            p.print(\"\u003cinitialized\u003e\");\n            break;\n        case IN_PROGRESS:\n            p.print(\"\u003cin progress\u003e\");\n            break;\n        }\n        p.println();\n        return (baos.toString());\n    }\n\n    /**\n     * Compares two digests for equality. Two digests are equal if they have\n     * the same length and all bytes at corresponding positions are equal.\n     *\n     * @implNote\n     * All bytes in {@code digesta} are examined to determine equality.\n     * The calculation time depends only on the length of {@code digesta}.\n     * It does not depend on the length of {@code digestb} or the contents\n     * of {@code digesta} and {@code digestb}.\n     *\n     * @param digesta one of the digests to compare.\n     *\n     * @param digestb the other digest to compare.\n     *\n     * @return true if the digests are equal, false otherwise.\n     */\n    public static boolean isEqual(byte[] digesta, byte[] digestb) {\n        if (digesta \u003d\u003d digestb) return true;\n        if (digesta \u003d\u003d null || digestb \u003d\u003d null) {\n            return false;\n        }\n\n        int lenA \u003d digesta.length;\n        int lenB \u003d digestb.length;\n\n        if (lenB \u003d\u003d 0) {\n            return lenA \u003d\u003d 0;\n        }\n\n        int result \u003d 0;\n        result |\u003d lenA - lenB;\n\n        // time-constant comparison\n        for (int i \u003d 0; i \u003c lenA; i++) {\n            // If i \u003e\u003d lenB, indexB is 0; otherwise, i.\n            int indexB \u003d ((i - lenB) \u003e\u003e\u003e 31) * i;\n            result |\u003d digesta[i] ^ digestb[indexB];\n        }\n        return result \u003d\u003d 0;\n    }\n\n    /**\n     * Resets the digest for further use.\n     */\n    public void reset() {\n        engineReset();\n        state \u003d INITIAL;\n    }\n\n    /**\n     * Returns a string that identifies the algorithm, independent of\n     * implementation details. The name should be a standard\n     * Java Security name (such as \"SHA-256\").\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @return the name of the algorithm\n     */\n    public final String getAlgorithm() {\n        return this.algorithm;\n    }\n\n    /**\n     * Returns the length of the digest in bytes, or 0 if this operation is\n     * not supported by the provider and the implementation is not cloneable.\n     *\n     * @return the digest length in bytes, or 0 if this operation is not\n     * supported by the provider and the implementation is not cloneable.\n     *\n     * @since 1.2\n     */\n    public final int getDigestLength() {\n        int digestLen \u003d engineGetDigestLength();\n        if (digestLen \u003d\u003d 0) {\n            try {\n                MessageDigest md \u003d (MessageDigest)clone();\n                byte[] digest \u003d md.digest();\n                return digest.length;\n            } catch (CloneNotSupportedException e) {\n                return digestLen;\n            }\n        }\n        return digestLen;\n    }\n\n    /**\n     * Returns a clone if the implementation is cloneable.\n     *\n     * @return a clone if the implementation is cloneable.\n     *\n     * @throws    CloneNotSupportedException if this is called on an\n     * implementation that does not support {@code Cloneable}.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        if (this instanceof Cloneable) {\n            return super.clone();\n        } else {\n            throw new CloneNotSupportedException();\n        }\n    }\n\n\n    /*\n     * The following class allows providers to extend from MessageDigestSpi\n     * rather than from MessageDigest. It represents a MessageDigest with an\n     * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).\n     * If the provider implementation is an instance of MessageDigestSpi,\n     * the getInstance() methods above return an instance of this class, with\n     * the SPI object encapsulated.\n     *\n     * Note: All SPI methods from the original MessageDigest class have been\n     * moved up the hierarchy into a new class (MessageDigestSpi), which has\n     * been interposed in the hierarchy between the API (MessageDigest)\n     * and its original parent (Object).\n     */\n\n    private static class Delegate extends MessageDigest\n            implements MessageDigestSpi2 {\n        // use this class for spi objects which implements Cloneable\n        private static final class CloneableDelegate extends Delegate\n                implements Cloneable {\n\n            private CloneableDelegate(MessageDigestSpi digestSpi,\n                    String algorithm, Provider p) {\n                super(digestSpi, algorithm, p);\n            }\n        }\n\n        // The provider implementation (delegate)\n        private final MessageDigestSpi digestSpi;\n\n        // factory method used by MessageDigest class to create Delegate objs\n        static Delegate of(MessageDigestSpi digestSpi, String algo,\n                Provider p) {\n            Objects.requireNonNull(digestSpi);\n            boolean isCloneable \u003d (digestSpi instanceof Cloneable);\n            // Spi impls from SunPKCS11 provider implement Cloneable but their\n            // clone() may throw CloneNotSupportException\n            if (isCloneable \u0026\u0026 p.getName().startsWith(\"SunPKCS11\") \u0026\u0026\n                    p.getClass().getModule().getName().equals\n                    (\"jdk.crypto.cryptoki\")) {\n                try {\n                    digestSpi.clone();\n                } catch (CloneNotSupportedException cnse) {\n                    isCloneable \u003d false;\n                }\n            }\n            return (isCloneable? new CloneableDelegate(digestSpi, algo, p) :\n                    new Delegate(digestSpi, algo, p));\n        }\n\n        // private constructor\n        private Delegate(MessageDigestSpi digestSpi, String algorithm,\n                Provider p) {\n            super(algorithm, p);\n            this.digestSpi \u003d digestSpi;\n        }\n\n        /**\n         * Returns a clone if the delegate is cloneable.\n         *\n         * @return a clone if the delegate is cloneable.\n         *\n         * @throws    CloneNotSupportedException if this is called on a\n         * delegate that does not support {@code Cloneable}.\n         */\n        @Override\n        public Object clone() throws CloneNotSupportedException {\n            if (this instanceof Cloneable) {\n                // Because \u0027algorithm\u0027, \u0027provider\u0027, and \u0027state\u0027 are private\n                // members of our supertype, we must perform a cast to\n                // access them.\n                MessageDigest that \u003d new CloneableDelegate(\n                        (MessageDigestSpi)digestSpi.clone(),\n                        ((MessageDigest)this).algorithm,\n                        ((MessageDigest)this).provider);\n                that.state \u003d ((MessageDigest)this).state;\n                return that;\n            } else {\n                throw new CloneNotSupportedException();\n            }\n        }\n\n        @Override\n        protected int engineGetDigestLength() {\n            return digestSpi.engineGetDigestLength();\n        }\n\n        @Override\n        protected void engineUpdate(byte input) {\n            digestSpi.engineUpdate(input);\n        }\n\n        @Override\n        protected void engineUpdate(byte[] input, int offset, int len) {\n            digestSpi.engineUpdate(input, offset, len);\n        }\n\n        @Override\n        protected void engineUpdate(ByteBuffer input) {\n            digestSpi.engineUpdate(input);\n        }\n\n        @Override\n        public void engineUpdate(SecretKey key) throws InvalidKeyException {\n            if (digestSpi instanceof MessageDigestSpi2) {\n                ((MessageDigestSpi2)digestSpi).engineUpdate(key);\n            } else {\n                throw new UnsupportedOperationException\n                (\"Digest does not support update of SecretKey object\");\n            }\n        }\n\n        @Override\n        protected byte[] engineDigest() {\n            return digestSpi.engineDigest();\n        }\n\n        @Override\n        protected int engineDigest(byte[] buf, int offset, int len)\n            throws DigestException {\n                return digestSpi.engineDigest(buf, offset, len);\n        }\n\n        @Override\n        protected void engineReset() {\n            digestSpi.engineReset();\n        }\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 3:12:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/security/MessageDigest.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 3:17:03 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report D:\HTWG\Master\Concurrency\ConcurrencyScala\.metals\.reports\metals-full\2024-05-12\r_compiler-error_15-17-03-701.md
2024.05.12 15:17:05 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:17:17 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:18:09 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:19:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:19:21 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:19:47 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:20:37 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:20:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 3:20:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\npackage java.nio.charset;\n\n/**\n * Constant definitions for the standard {@link Charset charsets}. These\n * charsets are guaranteed to be available on every implementation of the Java\n * platform.\n *\n * @see \u003ca href\u003d\"Charset.html#standard\"\u003eStandard Charsets\u003c/a\u003e\n * @since 1.7\n */\npublic final class StandardCharsets {\n\n    // To avoid accidental eager initialization of often unused Charsets\n    // from happening while the VM is booting up, which may delay\n    // initialization of VM components, we should generally avoid depending\n    // on this class from elsewhere in java.base.\n\n    private StandardCharsets() {\n        throw new AssertionError(\"No java.nio.charset.StandardCharsets instances for you!\");\n    }\n\n    /**\n     * Seven-bit ASCII, also known as ISO646-US, also known as the\n     * Basic Latin block of the Unicode character set.\n     */\n    public static final Charset US_ASCII \u003d sun.nio.cs.US_ASCII.INSTANCE;\n\n    /**\n     * ISO Latin Alphabet {@literal No. 1}, also known as ISO-LATIN-1.\n     */\n    public static final Charset ISO_8859_1 \u003d sun.nio.cs.ISO_8859_1.INSTANCE;\n\n    /**\n     * Eight-bit UCS Transformation Format.\n     */\n    public static final Charset UTF_8 \u003d sun.nio.cs.UTF_8.INSTANCE;\n\n    /**\n     * Sixteen-bit UCS Transformation Format, big-endian byte order.\n     */\n    public static final Charset UTF_16BE \u003d new sun.nio.cs.UTF_16BE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, little-endian byte order.\n     */\n    public static final Charset UTF_16LE \u003d new sun.nio.cs.UTF_16LE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark.\n     */\n    public static final Charset UTF_16 \u003d new sun.nio.cs.UTF_16();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Mai 12, 2024 3:20:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.05.12 15:20:45 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:21:36 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
Mai 12, 2024 3:23:01 PM scala.meta.internal.pc.CompilerAccess handleError
SCHWERWIEGEND: A severe compiler error occurred, full details of the error can be found in the error report D:\HTWG\Master\Concurrency\ConcurrencyScala\.metals\.reports\metals-full\2024-05-12\r_compiler-error_15-23-01-897.md
2024.05.12 15:23:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:23:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:23:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:23:40 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:24:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:24:59 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:25:01 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:25:01 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:35:14 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 15:35:44 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 15:37:51 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:39:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:40:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:41:53 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:42:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:43:18 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:43:51 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:43:54 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:43:55 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:44:54 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 15:47:04 INFO  Shutting down server
2024.05.12 15:47:04 INFO  shutting down Metals
2024.05.12 15:47:04 INFO  Exiting server
2024.05.12 18:52:28 INFO  Started: Metals version 1.3.0 in folders 'D:\HTWG\Master\Concurrency\ConcurrencyScala' for client Visual Studio Code 1.89.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@51d6cc49]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@588276da]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@51d6cc49]
2024.05.12 18:52:28 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.05.12 18:52:39 INFO  no build target found for D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.05.12 18:52:41 INFO  time: code lens generation in 10s
2024.05.12 18:52:41 INFO  time: code lens generation in 8.54s
2024.05.12 19:34:53 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:35:08 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:35:17 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
Mai 12, 2024 7:36:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 342
2024.05.12 19:36:51 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:36:56 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:37:39 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:37:43 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:38:02 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:38:02 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:39:21 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:39:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/concurrent/Executors.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/concurrent/Executors.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 7:39:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/util/concurrent/Executors.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n *\n *\n *\n *\n *\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\npackage java.util.concurrent;\n\nimport static java.lang.ref.Reference.reachabilityFence;\nimport java.security.AccessControlContext;\nimport java.security.AccessControlException;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport sun.security.util.SecurityConstants;\n\n/**\n * Factory and utility methods for {@link Executor}, {@link\n * ExecutorService}, {@link ScheduledExecutorService}, {@link\n * ThreadFactory}, and {@link Callable} classes defined in this\n * package. This class supports the following kinds of methods:\n *\n * \u003cul\u003e\n *   \u003cli\u003eMethods that create and return an {@link ExecutorService}\n *       set up with commonly useful configuration settings.\n *   \u003cli\u003eMethods that create and return a {@link ScheduledExecutorService}\n *       set up with commonly useful configuration settings.\n *   \u003cli\u003eMethods that create and return a \"wrapped\" ExecutorService, that\n *       disables reconfiguration by making implementation-specific methods\n *       inaccessible.\n *   \u003cli\u003eMethods that create and return a {@link ThreadFactory}\n *       that sets newly created threads to a known state.\n *   \u003cli\u003eMethods that create and return a {@link Callable}\n *       out of other closure-like forms, so they can be used\n *       in execution methods requiring {@code Callable}.\n * \u003c/ul\u003e\n *\n * @since 1.5\n * @author Doug Lea\n */\npublic class Executors {\n\n    /**\n     * Creates a thread pool that reuses a fixed number of threads\n     * operating off a shared unbounded queue.  At any point, at most\n     * {@code nThreads} threads will be active processing tasks.\n     * If additional tasks are submitted when all threads are active,\n     * they will wait in the queue until a thread is available.\n     * If any thread terminates due to a failure during execution\n     * prior to shutdown, a new one will take its place if needed to\n     * execute subsequent tasks.  The threads in the pool will exist\n     * until it is explicitly {@link ExecutorService#shutdown shutdown}.\n     *\n     * @param nThreads the number of threads in the pool\n     * @return the newly created thread pool\n     * @throws IllegalArgumentException if {@code nThreads \u003c\u003d 0}\n     */\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue\u003cRunnable\u003e());\n    }\n\n    /**\n     * Creates a thread pool that maintains enough threads to support\n     * the given parallelism level, and may use multiple queues to\n     * reduce contention. The parallelism level corresponds to the\n     * maximum number of threads actively engaged in, or available to\n     * engage in, task processing. The actual number of threads may\n     * grow and shrink dynamically. A work-stealing pool makes no\n     * guarantees about the order in which submitted tasks are\n     * executed.\n     *\n     * @param parallelism the targeted parallelism level\n     * @return the newly created thread pool\n     * @throws IllegalArgumentException if {@code parallelism \u003c\u003d 0}\n     * @since 1.8\n     */\n    public static ExecutorService newWorkStealingPool(int parallelism) {\n        return new ForkJoinPool\n            (parallelism,\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n\n    /**\n     * Creates a work-stealing thread pool using the number of\n     * {@linkplain Runtime#availableProcessors available processors}\n     * as its target parallelism level.\n     *\n     * @return the newly created thread pool\n     * @see #newWorkStealingPool(int)\n     * @since 1.8\n     */\n    public static ExecutorService newWorkStealingPool() {\n        return new ForkJoinPool\n            (Runtime.getRuntime().availableProcessors(),\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n\n    /**\n     * Creates a thread pool that reuses a fixed number of threads\n     * operating off a shared unbounded queue, using the provided\n     * ThreadFactory to create new threads when needed.  At any point,\n     * at most {@code nThreads} threads will be active processing\n     * tasks.  If additional tasks are submitted when all threads are\n     * active, they will wait in the queue until a thread is\n     * available.  If any thread terminates due to a failure during\n     * execution prior to shutdown, a new one will take its place if\n     * needed to execute subsequent tasks.  The threads in the pool will\n     * exist until it is explicitly {@link ExecutorService#shutdown\n     * shutdown}.\n     *\n     * @param nThreads the number of threads in the pool\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created thread pool\n     * @throws NullPointerException if threadFactory is null\n     * @throws IllegalArgumentException if {@code nThreads \u003c\u003d 0}\n     */\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue\u003cRunnable\u003e(),\n                                      threadFactory);\n    }\n\n    /**\n     * Creates an Executor that uses a single worker thread operating\n     * off an unbounded queue. (Note however that if this single\n     * thread terminates due to a failure during execution prior to\n     * shutdown, a new one will take its place if needed to execute\n     * subsequent tasks.)  Tasks are guaranteed to execute\n     * sequentially, and no more than one task will be active at any\n     * given time. Unlike the otherwise equivalent\n     * {@code newFixedThreadPool(1)} the returned executor is\n     * guaranteed not to be reconfigurable to use additional threads.\n     *\n     * @return the newly created single-threaded Executor\n     */\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue\u003cRunnable\u003e()));\n    }\n\n    /**\n     * Creates an Executor that uses a single worker thread operating\n     * off an unbounded queue, and uses the provided ThreadFactory to\n     * create a new thread when needed. Unlike the otherwise\n     * equivalent {@code newFixedThreadPool(1, threadFactory)} the\n     * returned executor is guaranteed not to be reconfigurable to use\n     * additional threads.\n     *\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created single-threaded Executor\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue\u003cRunnable\u003e(),\n                                    threadFactory));\n    }\n\n    /**\n     * Creates a thread pool that creates new threads as needed, but\n     * will reuse previously constructed threads when they are\n     * available.  These pools will typically improve the performance\n     * of programs that execute many short-lived asynchronous tasks.\n     * Calls to {@code execute} will reuse previously constructed\n     * threads if available. If no existing thread is available, a new\n     * thread will be created and added to the pool. Threads that have\n     * not been used for sixty seconds are terminated and removed from\n     * the cache. Thus, a pool that remains idle for long enough will\n     * not consume any resources. Note that pools with similar\n     * properties but different details (for example, timeout parameters)\n     * may be created using {@link ThreadPoolExecutor} constructors.\n     *\n     * @return the newly created thread pool\n     */\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue\u003cRunnable\u003e());\n    }\n\n    /**\n     * Creates a thread pool that creates new threads as needed, but\n     * will reuse previously constructed threads when they are\n     * available, and uses the provided\n     * ThreadFactory to create new threads when needed.\n     *\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created thread pool\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue\u003cRunnable\u003e(),\n                                      threadFactory);\n    }\n\n    /**\n     * Creates a single-threaded executor that can schedule commands\n     * to run after a given delay, or to execute periodically.\n     * (Note however that if this single\n     * thread terminates due to a failure during execution prior to\n     * shutdown, a new one will take its place if needed to execute\n     * subsequent tasks.)  Tasks are guaranteed to execute\n     * sequentially, and no more than one task will be active at any\n     * given time. Unlike the otherwise equivalent\n     * {@code newScheduledThreadPool(1)} the returned executor is\n     * guaranteed not to be reconfigurable to use additional threads.\n     *\n     * @return the newly created scheduled executor\n     */\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1));\n    }\n\n    /**\n     * Creates a single-threaded executor that can schedule commands\n     * to run after a given delay, or to execute periodically.  (Note\n     * however that if this single thread terminates due to a failure\n     * during execution prior to shutdown, a new one will take its\n     * place if needed to execute subsequent tasks.)  Tasks are\n     * guaranteed to execute sequentially, and no more than one task\n     * will be active at any given time. Unlike the otherwise\n     * equivalent {@code newScheduledThreadPool(1, threadFactory)}\n     * the returned executor is guaranteed not to be reconfigurable to\n     * use additional threads.\n     *\n     * @param threadFactory the factory to use when creating new threads\n     * @return the newly created scheduled executor\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1, threadFactory));\n    }\n\n    /**\n     * Creates a thread pool that can schedule commands to run after a\n     * given delay, or to execute periodically.\n     * @param corePoolSize the number of threads to keep in the pool,\n     * even if they are idle\n     * @return the newly created scheduled thread pool\n     * @throws IllegalArgumentException if {@code corePoolSize \u003c 0}\n     */\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n\n    /**\n     * Creates a thread pool that can schedule commands to run after a\n     * given delay, or to execute periodically.\n     * @param corePoolSize the number of threads to keep in the pool,\n     * even if they are idle\n     * @param threadFactory the factory to use when the executor\n     * creates a new thread\n     * @return the newly created scheduled thread pool\n     * @throws IllegalArgumentException if {@code corePoolSize \u003c 0}\n     * @throws NullPointerException if threadFactory is null\n     */\n    public static ScheduledExecutorService newScheduledThreadPool(\n            int corePoolSize, ThreadFactory threadFactory) {\n        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\n    }\n\n    /**\n     * Returns an object that delegates all defined {@link\n     * ExecutorService} methods to the given executor, but not any\n     * other methods that might otherwise be accessible using\n     * casts. This provides a way to safely \"freeze\" configuration and\n     * disallow tuning of a given concrete implementation.\n     * @param executor the underlying implementation\n     * @return an {@code ExecutorService} instance\n     * @throws NullPointerException if executor null\n     */\n    public static ExecutorService unconfigurableExecutorService(ExecutorService executor) {\n        if (executor \u003d\u003d null)\n            throw new NullPointerException();\n        return new DelegatedExecutorService(executor);\n    }\n\n    /**\n     * Returns an object that delegates all defined {@link\n     * ScheduledExecutorService} methods to the given executor, but\n     * not any other methods that might otherwise be accessible using\n     * casts. This provides a way to safely \"freeze\" configuration and\n     * disallow tuning of a given concrete implementation.\n     * @param executor the underlying implementation\n     * @return a {@code ScheduledExecutorService} instance\n     * @throws NullPointerException if executor null\n     */\n    public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) {\n        if (executor \u003d\u003d null)\n            throw new NullPointerException();\n        return new DelegatedScheduledExecutorService(executor);\n    }\n\n    /**\n     * Returns a default thread factory used to create new threads.\n     * This factory creates all new threads used by an Executor in the\n     * same {@link ThreadGroup}. If there is a {@link\n     * java.lang.SecurityManager}, it uses the group of {@link\n     * System#getSecurityManager}, else the group of the thread\n     * invoking this {@code defaultThreadFactory} method. Each new\n     * thread is created as a non-daemon thread with priority set to\n     * the smaller of {@code Thread.NORM_PRIORITY} and the maximum\n     * priority permitted in the thread group.  New threads have names\n     * accessible via {@link Thread#getName} of\n     * \u003cem\u003epool-N-thread-M\u003c/em\u003e, where \u003cem\u003eN\u003c/em\u003e is the sequence\n     * number of this factory, and \u003cem\u003eM\u003c/em\u003e is the sequence number\n     * of the thread created by this factory.\n     * @return a thread factory\n     */\n    public static ThreadFactory defaultThreadFactory() {\n        return new DefaultThreadFactory();\n    }\n\n    /**\n     * Returns a thread factory used to create new threads that\n     * have the same permissions as the current thread.\n     * This factory creates threads with the same settings as {@link\n     * Executors#defaultThreadFactory}, additionally setting the\n     * AccessControlContext and contextClassLoader of new threads to\n     * be the same as the thread invoking this\n     * {@code privilegedThreadFactory} method.  A new\n     * {@code privilegedThreadFactory} can be created within an\n     * {@link AccessController#doPrivileged AccessController.doPrivileged}\n     * action setting the current thread\u0027s access control context to\n     * create threads with the selected permission settings holding\n     * within that action.\n     *\n     * \u003cp\u003eNote that while tasks running within such threads will have\n     * the same access control and class loader settings as the\n     * current thread, they need not have the same {@link\n     * java.lang.ThreadLocal} or {@link\n     * java.lang.InheritableThreadLocal} values. If necessary,\n     * particular values of thread locals can be set or reset before\n     * any task runs in {@link ThreadPoolExecutor} subclasses using\n     * {@link ThreadPoolExecutor#beforeExecute(Thread, Runnable)}.\n     * Also, if it is necessary to initialize worker threads to have\n     * the same InheritableThreadLocal settings as some other\n     * designated thread, you can create a custom ThreadFactory in\n     * which that thread waits for and services requests to create\n     * others that will inherit its values.\n     *\n     * @return a thread factory\n     * @throws AccessControlException if the current access control\n     * context does not have permission to both get and set context\n     * class loader\n     *\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static ThreadFactory privilegedThreadFactory() {\n        return new PrivilegedThreadFactory();\n    }\n\n    /**\n     * Returns a {@link Callable} object that, when\n     * called, runs the given task and returns the given result.  This\n     * can be useful when applying methods requiring a\n     * {@code Callable} to an otherwise resultless action.\n     * @param task the task to run\n     * @param result the result to return\n     * @param \u003cT\u003e the type of the result\n     * @return a callable object\n     * @throws NullPointerException if task null\n     */\n    public static \u003cT\u003e Callable\u003cT\u003e callable(Runnable task, T result) {\n        if (task \u003d\u003d null)\n            throw new NullPointerException();\n        return new RunnableAdapter\u003cT\u003e(task, result);\n    }\n\n    /**\n     * Returns a {@link Callable} object that, when\n     * called, runs the given task and returns {@code null}.\n     * @param task the task to run\n     * @return a callable object\n     * @throws NullPointerException if task null\n     */\n    public static Callable\u003cObject\u003e callable(Runnable task) {\n        if (task \u003d\u003d null)\n            throw new NullPointerException();\n        return new RunnableAdapter\u003cObject\u003e(task, null);\n    }\n\n    /**\n     * Returns a {@link Callable} object that, when\n     * called, runs the given privileged action and returns its result.\n     * @param action the privileged action to run\n     * @return a callable object\n     * @throws NullPointerException if action null\n     */\n    public static Callable\u003cObject\u003e callable(final PrivilegedAction\u003c?\u003e action) {\n        if (action \u003d\u003d null)\n            throw new NullPointerException();\n        return new Callable\u003cObject\u003e() {\n            public Object call() { return action.run(); }};\n    }\n\n    /**\n     * Returns a {@link Callable} object that, when\n     * called, runs the given privileged exception action and returns\n     * its result.\n     * @param action the privileged exception action to run\n     * @return a callable object\n     * @throws NullPointerException if action null\n     */\n    public static Callable\u003cObject\u003e callable(final PrivilegedExceptionAction\u003c?\u003e action) {\n        if (action \u003d\u003d null)\n            throw new NullPointerException();\n        return new Callable\u003cObject\u003e() {\n            public Object call() throws Exception { return action.run(); }};\n    }\n\n    /**\n     * Returns a {@link Callable} object that will, when called,\n     * execute the given {@code callable} under the current access\n     * control context. This method should normally be invoked within\n     * an {@link AccessController#doPrivileged AccessController.doPrivileged}\n     * action to create callables that will, if possible, execute\n     * under the selected permission settings holding within that\n     * action; or if not possible, throw an associated {@link\n     * AccessControlException}.\n     * @param callable the underlying task\n     * @param \u003cT\u003e the type of the callable\u0027s result\n     * @return a callable object\n     * @throws NullPointerException if callable null\n     *\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static \u003cT\u003e Callable\u003cT\u003e privilegedCallable(Callable\u003cT\u003e callable) {\n        if (callable \u003d\u003d null)\n            throw new NullPointerException();\n        return new PrivilegedCallable\u003cT\u003e(callable);\n    }\n\n    /**\n     * Returns a {@link Callable} object that will, when called,\n     * execute the given {@code callable} under the current access\n     * control context, with the current context class loader as the\n     * context class loader. This method should normally be invoked\n     * within an\n     * {@link AccessController#doPrivileged AccessController.doPrivileged}\n     * action to create callables that will, if possible, execute\n     * under the selected permission settings holding within that\n     * action; or if not possible, throw an associated {@link\n     * AccessControlException}.\n     *\n     * @param callable the underlying task\n     * @param \u003cT\u003e the type of the callable\u0027s result\n     * @return a callable object\n     * @throws NullPointerException if callable null\n     * @throws AccessControlException if the current access control\n     * context does not have permission to both set and get context\n     * class loader\n     *\n     * @deprecated This method is only useful in conjunction with\n     *       {@linkplain SecurityManager the Security Manager}, which is\n     *       deprecated and subject to removal in a future release.\n     *       Consequently, this method is also deprecated and subject to\n     *       removal. There is no replacement for the Security Manager or this\n     *       method.\n     */\n    @Deprecated(since\u003d\"17\", forRemoval\u003dtrue)\n    public static \u003cT\u003e Callable\u003cT\u003e privilegedCallableUsingCurrentClassLoader(Callable\u003cT\u003e callable) {\n        if (callable \u003d\u003d null)\n            throw new NullPointerException();\n        return new PrivilegedCallableUsingCurrentClassLoader\u003cT\u003e(callable);\n    }\n\n    // Non-public classes supporting the public methods\n\n    /**\n     * A callable that runs given task and returns given result.\n     */\n    private static final class RunnableAdapter\u003cT\u003e implements Callable\u003cT\u003e {\n        private final Runnable task;\n        private final T result;\n        RunnableAdapter(Runnable task, T result) {\n            this.task \u003d task;\n            this.result \u003d result;\n        }\n        public T call() {\n            task.run();\n            return result;\n        }\n        public String toString() {\n            return super.toString() + \"[Wrapped task \u003d \" + task + \"]\";\n        }\n    }\n\n    /**\n     * A callable that runs under established access control settings.\n     */\n    private static final class PrivilegedCallable\u003cT\u003e implements Callable\u003cT\u003e {\n        final Callable\u003cT\u003e task;\n        @SuppressWarnings(\"removal\")\n        final AccessControlContext acc;\n\n        @SuppressWarnings(\"removal\")\n        PrivilegedCallable(Callable\u003cT\u003e task) {\n            this.task \u003d task;\n            this.acc \u003d AccessController.getContext();\n        }\n\n        @SuppressWarnings(\"removal\")\n        public T call() throws Exception {\n            try {\n                return AccessController.doPrivileged(\n                    new PrivilegedExceptionAction\u003cT\u003e() {\n                        public T run() throws Exception {\n                            return task.call();\n                        }\n                    }, acc);\n            } catch (PrivilegedActionException e) {\n                throw e.getException();\n            }\n        }\n\n        public String toString() {\n            return super.toString() + \"[Wrapped task \u003d \" + task + \"]\";\n        }\n    }\n\n    /**\n     * A callable that runs under established access control settings and\n     * current ClassLoader.\n     */\n    private static final class PrivilegedCallableUsingCurrentClassLoader\u003cT\u003e\n            implements Callable\u003cT\u003e {\n        final Callable\u003cT\u003e task;\n        @SuppressWarnings(\"removal\")\n        final AccessControlContext acc;\n        final ClassLoader ccl;\n\n        @SuppressWarnings(\"removal\")\n        PrivilegedCallableUsingCurrentClassLoader(Callable\u003cT\u003e task) {\n            SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                // Calls to getContextClassLoader from this class\n                // never trigger a security check, but we check\n                // whether our callers have this permission anyways.\n                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n\n                // Whether setContextClassLoader turns out to be necessary\n                // or not, we fail fast if permission is not available.\n                sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n            }\n            this.task \u003d task;\n            this.acc \u003d AccessController.getContext();\n            this.ccl \u003d Thread.currentThread().getContextClassLoader();\n        }\n\n        @SuppressWarnings(\"removal\")\n        public T call() throws Exception {\n            try {\n                return AccessController.doPrivileged(\n                    new PrivilegedExceptionAction\u003cT\u003e() {\n                        public T run() throws Exception {\n                            Thread t \u003d Thread.currentThread();\n                            ClassLoader cl \u003d t.getContextClassLoader();\n                            if (ccl \u003d\u003d cl) {\n                                return task.call();\n                            } else {\n                                t.setContextClassLoader(ccl);\n                                try {\n                                    return task.call();\n                                } finally {\n                                    t.setContextClassLoader(cl);\n                                }\n                            }\n                        }\n                    }, acc);\n            } catch (PrivilegedActionException e) {\n                throw e.getException();\n            }\n        }\n\n        public String toString() {\n            return super.toString() + \"[Wrapped task \u003d \" + task + \"]\";\n        }\n    }\n\n    /**\n     * The default thread factory.\n     */\n    private static class DefaultThreadFactory implements ThreadFactory {\n        private static final AtomicInteger poolNumber \u003d new AtomicInteger(1);\n        private final ThreadGroup group;\n        private final AtomicInteger threadNumber \u003d new AtomicInteger(1);\n        private final String namePrefix;\n\n        DefaultThreadFactory() {\n            @SuppressWarnings(\"removal\")\n            SecurityManager s \u003d System.getSecurityManager();\n            group \u003d (s !\u003d null) ? s.getThreadGroup() :\n                                  Thread.currentThread().getThreadGroup();\n            namePrefix \u003d \"pool-\" +\n                          poolNumber.getAndIncrement() +\n                         \"-thread-\";\n        }\n\n        public Thread newThread(Runnable r) {\n            Thread t \u003d new Thread(group, r,\n                                  namePrefix + threadNumber.getAndIncrement(),\n                                  0);\n            if (t.isDaemon())\n                t.setDaemon(false);\n            if (t.getPriority() !\u003d Thread.NORM_PRIORITY)\n                t.setPriority(Thread.NORM_PRIORITY);\n            return t;\n        }\n    }\n\n    /**\n     * Thread factory capturing access control context and class loader.\n     */\n    private static class PrivilegedThreadFactory extends DefaultThreadFactory {\n        @SuppressWarnings(\"removal\")\n        final AccessControlContext acc;\n        final ClassLoader ccl;\n\n        @SuppressWarnings(\"removal\")\n        PrivilegedThreadFactory() {\n            super();\n            SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                // Calls to getContextClassLoader from this class\n                // never trigger a security check, but we check\n                // whether our callers have this permission anyways.\n                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n\n                // Fail fast\n                sm.checkPermission(new RuntimePermission(\"setContextClassLoader\"));\n            }\n            this.acc \u003d AccessController.getContext();\n            this.ccl \u003d Thread.currentThread().getContextClassLoader();\n        }\n\n        public Thread newThread(final Runnable r) {\n            return super.newThread(new Runnable() {\n                @SuppressWarnings(\"removal\")\n                public void run() {\n                    AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                        public Void run() {\n                            Thread.currentThread().setContextClassLoader(ccl);\n                            r.run();\n                            return null;\n                        }\n                    }, acc);\n                }\n            });\n        }\n    }\n\n    /**\n     * A wrapper class that exposes only the ExecutorService methods\n     * of an ExecutorService implementation.\n     */\n    private static class DelegatedExecutorService\n            implements ExecutorService {\n        private final ExecutorService e;\n        DelegatedExecutorService(ExecutorService executor) { e \u003d executor; }\n        public void execute(Runnable command) {\n            try {\n                e.execute(command);\n            } finally { reachabilityFence(this); }\n        }\n        public void shutdown() { e.shutdown(); }\n        public List\u003cRunnable\u003e shutdownNow() {\n            try {\n                return e.shutdownNow();\n            } finally { reachabilityFence(this); }\n        }\n        public boolean isShutdown() {\n            try {\n                return e.isShutdown();\n            } finally { reachabilityFence(this); }\n        }\n        public boolean isTerminated() {\n            try {\n                return e.isTerminated();\n            } finally { reachabilityFence(this); }\n        }\n        public boolean awaitTermination(long timeout, TimeUnit unit)\n            throws InterruptedException {\n            try {\n                return e.awaitTermination(timeout, unit);\n            } finally { reachabilityFence(this); }\n        }\n        public Future\u003c?\u003e submit(Runnable task) {\n            try {\n                return e.submit(task);\n            } finally { reachabilityFence(this); }\n        }\n        public \u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task) {\n            try {\n                return e.submit(task);\n            } finally { reachabilityFence(this); }\n        }\n        public \u003cT\u003e Future\u003cT\u003e submit(Runnable task, T result) {\n            try {\n                return e.submit(task, result);\n            } finally { reachabilityFence(this); }\n        }\n        public \u003cT\u003e List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)\n            throws InterruptedException {\n            try {\n                return e.invokeAll(tasks);\n            } finally { reachabilityFence(this); }\n        }\n        public \u003cT\u003e List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks,\n                                             long timeout, TimeUnit unit)\n            throws InterruptedException {\n            try {\n                return e.invokeAll(tasks, timeout, unit);\n            } finally { reachabilityFence(this); }\n        }\n        public \u003cT\u003e T invokeAny(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks)\n            throws InterruptedException, ExecutionException {\n            try {\n                return e.invokeAny(tasks);\n            } finally { reachabilityFence(this); }\n        }\n        public \u003cT\u003e T invokeAny(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks,\n                               long timeout, TimeUnit unit)\n            throws InterruptedException, ExecutionException, TimeoutException {\n            try {\n                return e.invokeAny(tasks, timeout, unit);\n            } finally { reachabilityFence(this); }\n        }\n    }\n\n    private static class FinalizableDelegatedExecutorService\n            extends DelegatedExecutorService {\n        FinalizableDelegatedExecutorService(ExecutorService executor) {\n            super(executor);\n        }\n        @SuppressWarnings(\"deprecation\")\n        protected void finalize() {\n            super.shutdown();\n        }\n    }\n\n    /**\n     * A wrapper class that exposes only the ScheduledExecutorService\n     * methods of a ScheduledExecutorService implementation.\n     */\n    private static class DelegatedScheduledExecutorService\n            extends DelegatedExecutorService\n            implements ScheduledExecutorService {\n        private final ScheduledExecutorService e;\n        DelegatedScheduledExecutorService(ScheduledExecutorService executor) {\n            super(executor);\n            e \u003d executor;\n        }\n        public ScheduledFuture\u003c?\u003e schedule(Runnable command, long delay, TimeUnit unit) {\n            return e.schedule(command, delay, unit);\n        }\n        public \u003cV\u003e ScheduledFuture\u003cV\u003e schedule(Callable\u003cV\u003e callable, long delay, TimeUnit unit) {\n            return e.schedule(callable, delay, unit);\n        }\n        public ScheduledFuture\u003c?\u003e scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n            return e.scheduleAtFixedRate(command, initialDelay, period, unit);\n        }\n        public ScheduledFuture\u003c?\u003e scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {\n            return e.scheduleWithFixedDelay(command, initialDelay, delay, unit);\n        }\n    }\n\n    /** Cannot instantiate. */\n    private Executors() {}\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/concurrent/Executors.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/concurrent/Executors.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 7:39:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/util/concurrent/Executors.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/concurrent/Executors.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/util/concurrent/Executors.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 7:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 481
Mai 12, 2024 7:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 483
Mai 12, 2024 7:39:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 488
2024.05.12 19:39:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
Mai 12, 2024 7:39:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 502
Mai 12, 2024 7:39:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 504
Mai 12, 2024 7:39:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 508
2024.05.12 19:40:18 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 7:40:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/security/MessageDigest.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.security;\n\nimport java.util.*;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.nio.ByteBuffer;\n\nimport sun.security.jca.GetInstance;\nimport sun.security.util.Debug;\nimport sun.security.util.MessageDigestSpi2;\n\nimport javax.crypto.SecretKey;\n\n/**\n * This MessageDigest class provides applications the functionality of a\n * message digest algorithm, such as SHA-1 or SHA-256.\n * Message digests are secure one-way hash functions that take arbitrary-sized\n * data and output a fixed-length hash value.\n *\n * \u003cp\u003eA MessageDigest object starts out initialized. The data is\n * processed through it using the {@link #update(byte) update}\n * methods. At any point {@link #reset() reset} can be called\n * to reset the digest. Once all the data to be updated has been\n * updated, one of the {@link #digest() digest} methods should\n * be called to complete the hash computation.\n *\n * \u003cp\u003eThe {@code digest} method can be called once for a given number\n * of updates. After {@code digest} has been called, the MessageDigest\n * object is reset to its initialized state.\n *\n * \u003cp\u003eImplementations are free to implement the Cloneable interface.\n * Client applications can test cloneability by attempting cloning\n * and catching the CloneNotSupportedException:\n *\n * \u003cpre\u003e{@code\n * MessageDigest md \u003d MessageDigest.getInstance(\"SHA-256\");\n *\n * try {\n *     md.update(toChapter1);\n *     MessageDigest tc1 \u003d md.clone();\n *     byte[] toChapter1Digest \u003d tc1.digest();\n *     md.update(toChapter2);\n *     ...etc.\n * } catch (CloneNotSupportedException cnse) {\n *     throw new DigestException(\"couldn\u0027t make digest of partial content\");\n * }\n * }\u003c/pre\u003e\n *\n * \u003cp\u003eNote that if a given implementation is not cloneable, it is\n * still possible to compute intermediate digests by instantiating\n * several instances, if the number of digests is known in advance.\n *\n * \u003cp\u003eNote that this class is abstract and extends from\n * {@code MessageDigestSpi} for historical reasons.\n * Application developers should only take notice of the methods defined in\n * this {@code MessageDigest} class; all the methods in\n * the superclass are intended for cryptographic service providers who wish to\n * supply their own implementations of message digest algorithms.\n *\n * \u003cp\u003e Every implementation of the Java platform is required to support\n * the following standard {@code MessageDigest} algorithms:\n * \u003cul\u003e\n * \u003cli\u003e{@code SHA-1}\u003c/li\u003e\n * \u003cli\u003e{@code SHA-256}\u003c/li\u003e\n * \u003c/ul\u003e\n * These algorithms are described in the \u003ca href\u003d\n * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n * MessageDigest section\u003c/a\u003e of the\n * Java Security Standard Algorithm Names Specification.\n * Consult the release documentation for your implementation to see if any\n * other algorithms are supported.\n *\n * @author Benjamin Renaud\n * @since 1.1\n *\n * @see DigestInputStream\n * @see DigestOutputStream\n */\n\npublic abstract class MessageDigest extends MessageDigestSpi {\n\n    private static final Debug pdebug \u003d\n                        Debug.getInstance(\"provider\", \"Provider\");\n    private static final boolean skipDebug \u003d\n        Debug.isOn(\"engine\u003d\") \u0026\u0026 !Debug.isOn(\"messagedigest\");\n\n    private String algorithm;\n\n    // The state of this digest\n    private static final int INITIAL \u003d 0;\n    private static final int IN_PROGRESS \u003d 1;\n    private int state \u003d INITIAL;\n\n    // The provider\n    private Provider provider;\n\n    /**\n     * Creates a message digest with the specified algorithm name.\n     *\n     * @param algorithm the standard name of the digest algorithm.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     */\n    protected MessageDigest(String algorithm) {\n        this.algorithm \u003d algorithm;\n    }\n\n    // private constructor used only by Delegate class\n    private MessageDigest(String algorithm, Provider p) {\n        this.algorithm \u003d algorithm;\n        this.provider \u003d p;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e This method traverses the list of registered security Providers,\n     * starting with the most preferred Provider.\n     * A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the first\n     * Provider that supports the specified algorithm is returned.\n     *\n     * \u003cp\u003e Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @implNote\n     * The JDK Reference Implementation additionally uses the\n     * {@code jdk.security.provider.preferred}\n     * {@link Security#getProperty(String) Security} property to determine\n     * the preferred provider order for the specified algorithm. This\n     * may be different than the order of providers returned by\n     * {@link Security#getProviders() Security.getProviders()}.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws NoSuchAlgorithmException if no {@code Provider} supports a\n     *         {@code MessageDigestSpi} implementation for the\n     *         specified algorithm\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     */\n    public static MessageDigest getInstance(String algorithm)\n        throws NoSuchAlgorithmException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        MessageDigest md;\n\n        GetInstance.Instance instance \u003d GetInstance.getInstance(\"MessageDigest\",\n                MessageDigestSpi.class, algorithm);\n        if (instance.impl instanceof MessageDigest messageDigest) {\n            md \u003d messageDigest;\n            md.provider \u003d instance.provider;\n        } else {\n            md \u003d Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n                instance.provider);\n        }\n\n        if (!skipDebug \u0026\u0026 pdebug !\u003d null) {\n            pdebug.println(\"MessageDigest.\" + algorithm +\n                \" algorithm from: \" + md.provider.getName());\n        }\n\n        return md;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the specified provider\n     * is returned.  The specified provider must be registered\n     * in the security provider list.\n     *\n     * \u003cp\u003e Note that the list of registered providers may be retrieved via\n     * the {@link Security#getProviders() Security.getProviders()} method.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @param provider the name of the provider.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws IllegalArgumentException if the provider name is {@code null}\n     *         or empty\n     *\n     * @throws NoSuchAlgorithmException if a {@code MessageDigestSpi}\n     *         implementation for the specified algorithm is not\n     *         available from the specified provider\n     *\n     * @throws NoSuchProviderException if the specified provider is not\n     *         registered in the security provider list\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     */\n    public static MessageDigest getInstance(String algorithm, String provider)\n        throws NoSuchAlgorithmException, NoSuchProviderException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        if (provider \u003d\u003d null || provider.isEmpty())\n            throw new IllegalArgumentException(\"missing provider\");\n\n        MessageDigest md;\n        GetInstance.Instance instance \u003d GetInstance.getInstance(\"MessageDigest\",\n                MessageDigestSpi.class, algorithm, provider);\n        if (instance.impl instanceof MessageDigest messageDigest) {\n            md \u003d messageDigest;\n            md.provider \u003d instance.provider;\n        } else {\n            md \u003d Delegate.of((MessageDigestSpi)instance.impl, algorithm,\n                    instance.provider);\n        }\n        return md;\n    }\n\n    /**\n     * Returns a MessageDigest object that implements the specified digest\n     * algorithm.\n     *\n     * \u003cp\u003e A new MessageDigest object encapsulating the\n     * MessageDigestSpi implementation from the specified Provider\n     * object is returned.  Note that the specified Provider object\n     * does not have to be registered in the provider list.\n     *\n     * @param algorithm the name of the algorithm requested.\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @param provider the provider.\n     *\n     * @return a {@code MessageDigest} object that implements the\n     *         specified algorithm\n     *\n     * @throws IllegalArgumentException if the specified provider is\n     *         {@code null}\n     *\n     * @throws NoSuchAlgorithmException if a {@code MessageDigestSpi}\n     *         implementation for the specified algorithm is not available\n     *         from the specified {@code Provider} object\n     *\n     * @throws NullPointerException if {@code algorithm} is {@code null}\n     *\n     * @see Provider\n     *\n     * @since 1.4\n     */\n    public static MessageDigest getInstance(String algorithm,\n                                            Provider provider)\n        throws NoSuchAlgorithmException\n    {\n        Objects.requireNonNull(algorithm, \"null algorithm name\");\n        if (provider \u003d\u003d null)\n            throw new IllegalArgumentException(\"missing provider\");\n        Object[] objs \u003d Security.getImpl(algorithm, \"MessageDigest\", provider);\n        if (objs[0] instanceof MessageDigest md) {\n            md.provider \u003d (Provider)objs[1];\n            return md;\n        } else {\n            MessageDigest delegate \u003d\n                    Delegate.of((MessageDigestSpi)objs[0], algorithm,\n                    (Provider)objs[1]);\n            return delegate;\n        }\n    }\n\n    /**\n     * Returns the provider of this message digest object.\n     *\n     * @return the provider of this message digest object\n     */\n    public final Provider getProvider() {\n        return this.provider;\n    }\n\n    /**\n     * Updates the digest using the specified byte.\n     *\n     * @param input the byte with which to update the digest.\n     */\n    public void update(byte input) {\n        engineUpdate(input);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Updates the digest using the specified array of bytes, starting\n     * at the specified offset.\n     *\n     * @param input the array of bytes.\n     *\n     * @param offset the offset to start from in the array of bytes.\n     *\n     * @param len the number of bytes to use, starting at\n     * {@code offset}.\n     */\n    public void update(byte[] input, int offset, int len) {\n        if (input \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No input buffer given\");\n        }\n        if (input.length - offset \u003c len) {\n            throw new IllegalArgumentException(\"Input buffer too short\");\n        }\n        engineUpdate(input, offset, len);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Updates the digest using the specified array of bytes.\n     *\n     * @param input the array of bytes.\n     */\n    public void update(byte[] input) {\n        engineUpdate(input, 0, input.length);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Update the digest using the specified ByteBuffer. The digest is\n     * updated using the {@code input.remaining()} bytes starting\n     * at {@code input.position()}.\n     * Upon return, the buffer\u0027s position will be equal to its limit;\n     * its limit will not have changed.\n     *\n     * @param input the ByteBuffer\n     * @since 1.5\n     */\n    public final void update(ByteBuffer input) {\n        if (input \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        engineUpdate(input);\n        state \u003d IN_PROGRESS;\n    }\n\n    /**\n     * Completes the hash computation by performing final operations\n     * such as padding. The digest is reset after this call is made.\n     *\n     * @return the array of bytes for the resulting hash value.\n     */\n    public byte[] digest() {\n        /* Resetting is the responsibility of implementors. */\n        byte[] result \u003d engineDigest();\n        state \u003d INITIAL;\n        return result;\n    }\n\n    /**\n     * Completes the hash computation by performing final operations\n     * such as padding. The digest is reset after this call is made.\n     *\n     * @param buf output buffer for the computed digest\n     *\n     * @param offset offset into the output buffer to begin storing the digest\n     *\n     * @param len number of bytes within buf allotted for the digest\n     *\n     * @return the number of bytes placed into {@code buf}\n     *\n     * @throws    DigestException if an error occurs.\n     */\n    public int digest(byte[] buf, int offset, int len) throws DigestException {\n        if (buf \u003d\u003d null) {\n            throw new IllegalArgumentException(\"No output buffer given\");\n        }\n        if (buf.length - offset \u003c len) {\n            throw new IllegalArgumentException\n                (\"Output buffer too small for specified offset and length\");\n        }\n        int numBytes \u003d engineDigest(buf, offset, len);\n        state \u003d INITIAL;\n        return numBytes;\n    }\n\n    /**\n     * Performs a final update on the digest using the specified array\n     * of bytes, then completes the digest computation. That is, this\n     * method first calls {@link #update(byte[]) update(input)},\n     * passing the \u003ci\u003einput\u003c/i\u003e array to the {@code update} method,\n     * then calls {@link #digest() digest()}.\n     *\n     * @param input the input to be updated before the digest is\n     * completed.\n     *\n     * @return the array of bytes for the resulting hash value.\n     */\n    public byte[] digest(byte[] input) {\n        update(input);\n        return digest();\n    }\n\n    private String getProviderName() {\n        return (provider \u003d\u003d null) ? \"(no provider)\" : provider.getName();\n    }\n\n    /**\n     * Returns a string representation of this message digest object.\n     */\n    public String toString() {\n        ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n        PrintStream p \u003d new PrintStream(baos);\n        p.print(algorithm+\" Message Digest from \"+getProviderName()+\", \");\n        switch (state) {\n        case INITIAL:\n            p.print(\"\u003cinitialized\u003e\");\n            break;\n        case IN_PROGRESS:\n            p.print(\"\u003cin progress\u003e\");\n            break;\n        }\n        p.println();\n        return (baos.toString());\n    }\n\n    /**\n     * Compares two digests for equality. Two digests are equal if they have\n     * the same length and all bytes at corresponding positions are equal.\n     *\n     * @implNote\n     * All bytes in {@code digesta} are examined to determine equality.\n     * The calculation time depends only on the length of {@code digesta}.\n     * It does not depend on the length of {@code digestb} or the contents\n     * of {@code digesta} and {@code digestb}.\n     *\n     * @param digesta one of the digests to compare.\n     *\n     * @param digestb the other digest to compare.\n     *\n     * @return true if the digests are equal, false otherwise.\n     */\n    public static boolean isEqual(byte[] digesta, byte[] digestb) {\n        if (digesta \u003d\u003d digestb) return true;\n        if (digesta \u003d\u003d null || digestb \u003d\u003d null) {\n            return false;\n        }\n\n        int lenA \u003d digesta.length;\n        int lenB \u003d digestb.length;\n\n        if (lenB \u003d\u003d 0) {\n            return lenA \u003d\u003d 0;\n        }\n\n        int result \u003d 0;\n        result |\u003d lenA - lenB;\n\n        // time-constant comparison\n        for (int i \u003d 0; i \u003c lenA; i++) {\n            // If i \u003e\u003d lenB, indexB is 0; otherwise, i.\n            int indexB \u003d ((i - lenB) \u003e\u003e\u003e 31) * i;\n            result |\u003d digesta[i] ^ digestb[indexB];\n        }\n        return result \u003d\u003d 0;\n    }\n\n    /**\n     * Resets the digest for further use.\n     */\n    public void reset() {\n        engineReset();\n        state \u003d INITIAL;\n    }\n\n    /**\n     * Returns a string that identifies the algorithm, independent of\n     * implementation details. The name should be a standard\n     * Java Security name (such as \"SHA-256\").\n     * See the MessageDigest section in the \u003ca href\u003d\n     * \"{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms\"\u003e\n     * Java Security Standard Algorithm Names Specification\u003c/a\u003e\n     * for information about standard algorithm names.\n     *\n     * @return the name of the algorithm\n     */\n    public final String getAlgorithm() {\n        return this.algorithm;\n    }\n\n    /**\n     * Returns the length of the digest in bytes, or 0 if this operation is\n     * not supported by the provider and the implementation is not cloneable.\n     *\n     * @return the digest length in bytes, or 0 if this operation is not\n     * supported by the provider and the implementation is not cloneable.\n     *\n     * @since 1.2\n     */\n    public final int getDigestLength() {\n        int digestLen \u003d engineGetDigestLength();\n        if (digestLen \u003d\u003d 0) {\n            try {\n                MessageDigest md \u003d (MessageDigest)clone();\n                byte[] digest \u003d md.digest();\n                return digest.length;\n            } catch (CloneNotSupportedException e) {\n                return digestLen;\n            }\n        }\n        return digestLen;\n    }\n\n    /**\n     * Returns a clone if the implementation is cloneable.\n     *\n     * @return a clone if the implementation is cloneable.\n     *\n     * @throws    CloneNotSupportedException if this is called on an\n     * implementation that does not support {@code Cloneable}.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        if (this instanceof Cloneable) {\n            return super.clone();\n        } else {\n            throw new CloneNotSupportedException();\n        }\n    }\n\n\n    /*\n     * The following class allows providers to extend from MessageDigestSpi\n     * rather than from MessageDigest. It represents a MessageDigest with an\n     * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).\n     * If the provider implementation is an instance of MessageDigestSpi,\n     * the getInstance() methods above return an instance of this class, with\n     * the SPI object encapsulated.\n     *\n     * Note: All SPI methods from the original MessageDigest class have been\n     * moved up the hierarchy into a new class (MessageDigestSpi), which has\n     * been interposed in the hierarchy between the API (MessageDigest)\n     * and its original parent (Object).\n     */\n\n    private static class Delegate extends MessageDigest\n            implements MessageDigestSpi2 {\n        // use this class for spi objects which implements Cloneable\n        private static final class CloneableDelegate extends Delegate\n                implements Cloneable {\n\n            private CloneableDelegate(MessageDigestSpi digestSpi,\n                    String algorithm, Provider p) {\n                super(digestSpi, algorithm, p);\n            }\n        }\n\n        // The provider implementation (delegate)\n        private final MessageDigestSpi digestSpi;\n\n        // factory method used by MessageDigest class to create Delegate objs\n        static Delegate of(MessageDigestSpi digestSpi, String algo,\n                Provider p) {\n            Objects.requireNonNull(digestSpi);\n            boolean isCloneable \u003d (digestSpi instanceof Cloneable);\n            // Spi impls from SunPKCS11 provider implement Cloneable but their\n            // clone() may throw CloneNotSupportException\n            if (isCloneable \u0026\u0026 p.getName().startsWith(\"SunPKCS11\") \u0026\u0026\n                    p.getClass().getModule().getName().equals\n                    (\"jdk.crypto.cryptoki\")) {\n                try {\n                    digestSpi.clone();\n                } catch (CloneNotSupportedException cnse) {\n                    isCloneable \u003d false;\n                }\n            }\n            return (isCloneable? new CloneableDelegate(digestSpi, algo, p) :\n                    new Delegate(digestSpi, algo, p));\n        }\n\n        // private constructor\n        private Delegate(MessageDigestSpi digestSpi, String algorithm,\n                Provider p) {\n            super(algorithm, p);\n            this.digestSpi \u003d digestSpi;\n        }\n\n        /**\n         * Returns a clone if the delegate is cloneable.\n         *\n         * @return a clone if the delegate is cloneable.\n         *\n         * @throws    CloneNotSupportedException if this is called on a\n         * delegate that does not support {@code Cloneable}.\n         */\n        @Override\n        public Object clone() throws CloneNotSupportedException {\n            if (this instanceof Cloneable) {\n                // Because \u0027algorithm\u0027, \u0027provider\u0027, and \u0027state\u0027 are private\n                // members of our supertype, we must perform a cast to\n                // access them.\n                MessageDigest that \u003d new CloneableDelegate(\n                        (MessageDigestSpi)digestSpi.clone(),\n                        ((MessageDigest)this).algorithm,\n                        ((MessageDigest)this).provider);\n                that.state \u003d ((MessageDigest)this).state;\n                return that;\n            } else {\n                throw new CloneNotSupportedException();\n            }\n        }\n\n        @Override\n        protected int engineGetDigestLength() {\n            return digestSpi.engineGetDigestLength();\n        }\n\n        @Override\n        protected void engineUpdate(byte input) {\n            digestSpi.engineUpdate(input);\n        }\n\n        @Override\n        protected void engineUpdate(byte[] input, int offset, int len) {\n            digestSpi.engineUpdate(input, offset, len);\n        }\n\n        @Override\n        protected void engineUpdate(ByteBuffer input) {\n            digestSpi.engineUpdate(input);\n        }\n\n        @Override\n        public void engineUpdate(SecretKey key) throws InvalidKeyException {\n            if (digestSpi instanceof MessageDigestSpi2) {\n                ((MessageDigestSpi2)digestSpi).engineUpdate(key);\n            } else {\n                throw new UnsupportedOperationException\n                (\"Digest does not support update of SecretKey object\");\n            }\n        }\n\n        @Override\n        protected byte[] engineDigest() {\n            return digestSpi.engineDigest();\n        }\n\n        @Override\n        protected int engineDigest(byte[] buf, int offset, int len)\n            throws DigestException {\n                return digestSpi.engineDigest(buf, offset, len);\n        }\n\n        @Override\n        protected void engineReset() {\n            digestSpi.engineReset();\n        }\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 7:40:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/security/MessageDigest.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/security/MessageDigest.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.05.12 19:43:39 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:43:40 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 7:43:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\npackage java.nio.charset;\n\n/**\n * Constant definitions for the standard {@link Charset charsets}. These\n * charsets are guaranteed to be available on every implementation of the Java\n * platform.\n *\n * @see \u003ca href\u003d\"Charset.html#standard\"\u003eStandard Charsets\u003c/a\u003e\n * @since 1.7\n */\npublic final class StandardCharsets {\n\n    // To avoid accidental eager initialization of often unused Charsets\n    // from happening while the VM is booting up, which may delay\n    // initialization of VM components, we should generally avoid depending\n    // on this class from elsewhere in java.base.\n\n    private StandardCharsets() {\n        throw new AssertionError(\"No java.nio.charset.StandardCharsets instances for you!\");\n    }\n\n    /**\n     * Seven-bit ASCII, also known as ISO646-US, also known as the\n     * Basic Latin block of the Unicode character set.\n     */\n    public static final Charset US_ASCII \u003d sun.nio.cs.US_ASCII.INSTANCE;\n\n    /**\n     * ISO Latin Alphabet {@literal No. 1}, also known as ISO-LATIN-1.\n     */\n    public static final Charset ISO_8859_1 \u003d sun.nio.cs.ISO_8859_1.INSTANCE;\n\n    /**\n     * Eight-bit UCS Transformation Format.\n     */\n    public static final Charset UTF_8 \u003d sun.nio.cs.UTF_8.INSTANCE;\n\n    /**\n     * Sixteen-bit UCS Transformation Format, big-endian byte order.\n     */\n    public static final Charset UTF_16BE \u003d new sun.nio.cs.UTF_16BE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, little-endian byte order.\n     */\n    public static final Charset UTF_16LE \u003d new sun.nio.cs.UTF_16LE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark.\n     */\n    public static final Charset UTF_16 \u003d new sun.nio.cs.UTF_16();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Mai 12, 2024 7:43:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.05.12 19:44:54 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:45:05 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:47:11 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:47:19 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:47:29 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:47:41 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:48:52 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:48:55 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:48:56 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:48:57 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:49:11 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:49:17 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
Mai 12, 2024 7:49:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 810
Mai 12, 2024 7:50:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 832
Mai 12, 2024 7:50:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 857
2024.05.12 19:50:59 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:51:06 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:51:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:51:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:51:15 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:51:38 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:52:00 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:52:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Mai 12, 2024 7:52:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\npackage java.nio.charset;\n\n/**\n * Constant definitions for the standard {@link Charset charsets}. These\n * charsets are guaranteed to be available on every implementation of the Java\n * platform.\n *\n * @see \u003ca href\u003d\"Charset.html#standard\"\u003eStandard Charsets\u003c/a\u003e\n * @since 1.7\n */\npublic final class StandardCharsets {\n\n    // To avoid accidental eager initialization of often unused Charsets\n    // from happening while the VM is booting up, which may delay\n    // initialization of VM components, we should generally avoid depending\n    // on this class from elsewhere in java.base.\n\n    private StandardCharsets() {\n        throw new AssertionError(\"No java.nio.charset.StandardCharsets instances for you!\");\n    }\n\n    /**\n     * Seven-bit ASCII, also known as ISO646-US, also known as the\n     * Basic Latin block of the Unicode character set.\n     */\n    public static final Charset US_ASCII \u003d sun.nio.cs.US_ASCII.INSTANCE;\n\n    /**\n     * ISO Latin Alphabet {@literal No. 1}, also known as ISO-LATIN-1.\n     */\n    public static final Charset ISO_8859_1 \u003d sun.nio.cs.ISO_8859_1.INSTANCE;\n\n    /**\n     * Eight-bit UCS Transformation Format.\n     */\n    public static final Charset UTF_8 \u003d sun.nio.cs.UTF_8.INSTANCE;\n\n    /**\n     * Sixteen-bit UCS Transformation Format, big-endian byte order.\n     */\n    public static final Charset UTF_16BE \u003d new sun.nio.cs.UTF_16BE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, little-endian byte order.\n     */\n    public static final Charset UTF_16LE \u003d new sun.nio.cs.UTF_16LE();\n\n    /**\n     * Sixteen-bit UCS Transformation Format, byte order identified by an\n     * optional byte-order mark.\n     */\n    public static final Charset UTF_16 \u003d new sun.nio.cs.UTF_16();\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 15 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

Mai 12, 2024 7:52:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNUNG: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.base/java/nio/charset/StandardCharsets.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.base/java/nio/charset/StandardCharsets.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.05.12 19:52:33 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:53:50 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:53:50 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:54:30 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:54:36 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 19:55:11 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
Mai 12, 2024 7:55:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1060
2024.05.12 19:55:35 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:55:39 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:55:45 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:59:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:59:10 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:59:19 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 19:59:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
Mai 12, 2024 7:59:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 1625
2024.05.12 20:00:01 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:00:18 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:00:25 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:00:29 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 20:00:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:02:47 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:02:59 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:03:09 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:03:24 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:03:28 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:04:11 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:04:54 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:05:13 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:05:29 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:05:30 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:07:05 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:07:12 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:07:20 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:07:22 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:07:51 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:08:06 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:08:21 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:08:32 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:08:35 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:09:02 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:09:05 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:09:56 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:10:29 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:10:41 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:14:28 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:16:17 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:16:36 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:16:48 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:16:50 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:18:39 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:19:07 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:19:23 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:19:39 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWorkLimited.scala
2024.05.12 20:20:06 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:20:27 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:21:40 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:23:51 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:24:03 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:24:45 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:25:30 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:25:47 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:16 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:16 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:30 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:30 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:41 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:26:45 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
2024.05.12 20:27:50 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:27:54 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\ProofOfWork.scala
Mai 12, 2024 8:28:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNUNG: Unmatched cancel notification for request id 3303
2024.05.12 20:28:04 WARN  no build target for: D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala
2024.05.12 20:28:08 INFO  Shutting down server
2024.05.12 20:28:08 INFO  shutting down Metals
2024.05.12 20:28:08 INFO  Exiting server
2024.05.19 11:26:55 INFO  Started: Metals version 1.3.0 in folders 'D:\HTWG\Master\Concurrency\ConcurrencyScala' for client Visual Studio Code 1.89.1.
2024.05.19 11:26:57 INFO  time: initialize in 0.18s
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@5a036418]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@67a0d4b7]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@5a036418]
2024.05.19 11:26:59 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.05.19 11:27:32 INFO  no build target found for D:\HTWG\Master\Concurrency\ConcurrencyScala\src\main\scala\test\ProofOfWorkLimited.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.05.19 11:39:43 INFO  Shutting down server
2024.05.19 11:39:43 INFO  shutting down Metals
2024.05.19 11:39:45 INFO  Exiting server
2024.05.20 13:42:51 INFO  Started: Metals version 1.3.1 in folders 'D:\HTWG\Master\Concurrency\ConcurrencyScala' for client Visual Studio Code 1.89.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@3f31920]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@4bc76230]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@3f31920]
2024.05.20 13:42:53 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.05.20 13:43:17 INFO  Shutting down server
2024.05.20 13:43:17 INFO  shutting down Metals
2024.05.20 13:43:17 INFO  Exiting server
2024.05.20 13:43:18 ERROR Unexpected error initializing server: 
org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Request window/showMessageRequest failed with message: Canceled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

